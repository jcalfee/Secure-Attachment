<!DOCTYPE HTML>
<html>
<head>
<title>Secure File</title>
<link rel="shortcut icon" type="image/ico" thref="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAknl//45zev+Lb3T/h2pv/4VobP+BZGn/fF5i/3pbX/94V1v/dVVY/3NRVf9wT1P/bU5S/2lLT/8AAAAAAAAAAJh/hf/l3+H/5d/h/+jj5v/u6uz/8vDx//Ty9P/08fL/7enr/+Hb3//b1df/2dHV/9nR1f9tTlL/AAAAAAAAAACchYr/5d/h/8O2uv+kkJb/rp2j/7alqv+5qK//t6et/6yYnv+bg4n/kXh+/6yYnv/b0tb/cVBU/wAAAAAAAAAAoImP/+bh5P/FuL7/zsTJ/9vS1v/j3eD/6OPm/+Pd4P/UzM//v7G2/7Gfpf+tm6H/29LW/3VVWP8AAAAAAAAAAKSPlf/o4+b/yb7D/6yYnv+zoKf/4dvf/41yef94V1v/2M7T/5+Ijv+Ue4H/sJ6k/9vV1/96WV3/AAAAAAAAAACplZr/6uXn/83Bxf/WzdD/3tfa/+Ha3f+Ue4H/gGJm/9jP1P/Ft7v/t6et/7alqv/g2Nv/fF1h/wAAAAAAAAAArZmf/+rm6f/Qxcr/sJ6k/7OhqP/g2Nv/m4OJ/5uDif/Z0dX/o46U/5uDif+3p63/4Njb/4Fkaf8AAAAAAAAAALCepP/r6Or/0cjM/9vS1v/e19r/3NbZ/+bh5P/l4OL/29XX/8m+w/+/r7X/vKyx/+Hb3/+FaGz/AAAAAAAAAACzoKf/6+jq/+vo6v/w7vD/8O7w/+/s7f/08vT/9PL0//Du8P/q5un/5uHk/+Xf4f/l3+H/i290/wAAAAAAAAAAtKSp/5B2e/+BY2f/f2Fl/6qXnf+ql53/p5OZ/6OOlP+giY//nIWK/2VJTf9kSE3/cE9T/45zev8AAAAAAAAAAAAAAACIbXLDuaiv/4Rma/+AYGAIAAAAAAAAAAAAAAAAAAAAAGBAQAhtTlL/nIWK/2NITMMAAAAAAAAAAAAAAAAAAAAAjXF4rramq/+ReH7/g2RqKQAAAAAAAAAAAAAAAAAAAABwUVEpelld/5mAhv9lSU6uAAAAAAAAAAAAAAAAAAAAAJB4fHWsmJ7/sJ6k/4dqcN2EY2sfZjNmBWYzMwVzWlofd1da5ZmAhv+Oc3r/bUxRdQAAAAAAAAAAAAAAAAAAAACAaoAMkHh+27amq/+unaP/kXh+/4Vpbv+EZmv/h2pv/52Hjf+dh43/dFVX23E5VQkAAAAAAAAAAAAAAAAAAAAAAAAAAI91gDCRd33erZmf/7yts/+/r7X/vK2z/7Skqf+chov/e11i3nVVWjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlWqADJB5f4GQdn26jHJ4zItuc8yGam66gmVrgYBVVQwAAAAAAAAAAAAAAAAAAAAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMfjAADH4wAA48cAAOAHAADwDwAA+B8AAA==" />
<style type="text/css">
#dropFrame {
  width: 600px;
  height: 6em;
  _border: none;
}
</style>
</head>

<body 
  onload="onBodyLoad()"
  ondragenter="dragEnterHandler(event)"
  ondragover="dragOverHandler(event)"
  ondrop="dropHandler(event)"
  onclick="bodyClick()">

<div id="passwordEntry" style="display: block">
  <form name="pwform" method="post" onsubmit="return passwordEntry()">
    <input id="password" name="pw" type="password"/>&nbsp;Password<br/>
  </form>
</div>

<div id="workspace" style="display: none">

<!-- Files show up in this list.  An iframe is used here because, 
un-encrypted data in the iframe is not saved when the page is saved. -->
<iframe id="dropFrame" scrolling="auto"
  ondragenter="dragEnterHandler(event)"
  ondragover="dragOverHandler(event)"
  ondrop="dropHandler(event)">
</iframe>

<div id="saveInstructions" style="display: none">
<img alt="Plus" src="data:image/gif;base64,R0lGODlhEAAQAIAAAAAAAP///yH5BAEAAAEALAAAAAAQABAAQAIejI+pAMbf1IEM1UmlTtdlHlHRRpbmaXaSqGotCmsFADs=">
Use the browser's Save Page As option under the File menu to save this page.<br>
</div>

<!-- <textarea id="msgInput" rows="10" cols="70"></textarea><br/> -->
<!-- <input id="fileInput" type="file" onchange="addFileInput()"/>
  &nbsp;<a href="#" onclick="addFileInput();false">add</a><br/> -->

<div id="encMessage" style="display: none">
<strong>&nbsp;+</strong>
Contents are secured with your password and encryption
(<a target="_blank" href="http://en.wikipedia.org/wiki/AES">AES</a> 256-bit for files under 80K.  
<a target="_blank" href="http://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm">TEA</a> 128-bit for larger files.)<br>

<img alt="Idea" style="float: left"
  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAA3NCSVQICAjb4U/gAAAAz1BMVEX////U1OW/v+26urqysqyUlJS/v+2bm8iUlJSkpNdtbW2Zmcy/v/SVlcKEhLaEhLbHx/+ZmcyMjLl1daa7u+WkpNeVlcJ+frSEhLZOTk6srNyZmcyJiYmEhLZ+frR5eXlVVVX////4+Pzv7/nj4/bd3ffe3unU1PbU1PHU1OXMzOvLy+PLy9/Gxu7FxeTFxdnExNzDw8K/v+27u+W6uuC2tuS2tt2zs+20tNmvr9msrNyqquikpNulpaWfn56ZmcyUlJSJib54eHNxcbBpaaXBZgKPAAAARXRSTlMAESIiIiIzMzNERFVmZmZ3qqq7u8zMzMzd3e7u7u7u7u7///////////////////////////////////////////////9mxir8AAAACXBIWXMAAArwAAAK8AFCrDSYAAAAK3RFWHRDcmVhdGlvbiBUaW1lAERpIDE2IEF1ZyAyMDA1IDIyOjU0OjMwICswMTAwXSnWnQAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTM5jWRgMAAACUSURBVBiVY2DACnhEjM1EeRF8AVUlJWUVMyG4vLoSUEBV3ZIfKiCirKwIVKGhLgEVMFVWVlPT1NZSdYQKSKmo6usYGOipyEIFBHU1tPX0LDR0haECTNK6unq6Jrpy7DBr2OyNLE2tHDkRDhEzt7GxFkdyKbeLs7MLH5IAi4OhnRMHkgCjjKGtPDOy71glFbiw+5sBAAzdEAWApbYHAAAAAElFTkSuQmCC" >
<span id="fileDropMessage" style="display: none;">
&nbsp;Drag and Drop files into this page.</span><script>
var pad = document.getElementById('fileDropMessage');
try {
  if(DragEvent) {
    //browser supports html 5 drag and drop
    pad.style.display = 'block';
  }
} catch(e) {
  //Specify display none too; encoding the page may loose the default 
  //#fileDropMessage.style element.
  pad.style.display = 'none';
}
</script>

<img alt="Caution" src="data:image/gif;base64,R0lGODlhEAAQAMQAAPR4e8gnL/Rmb/Nnb/NYY/JXY+mkqsgZKvLFyvTQ1PT3+8lHPvaSjsk6OPaIhvaHh////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAABAALAAAAAAQABAAAAVHICSOSqmMKKogy4KcqbowzALHorI8jo2TDQCgccMpAoJBoBhTHAqEAzOlMLQMU+pB+ut6IYlW4qtz9LKkg5nbXW1fZNP3GwIAOw==">
This file is not tamper-proof...
</div>

<!--
<a href="javascript:void(0);"
 onclick="document.execCommand('SaveAs',true,'file.html');"
 >Save this page</a><br/>

<a id="mailerLink" href="javascript:void(0);" 
  onclick="generateMailer()" style="display: none">mailer.html</a>
-->

</div><!--workspace-->

<p><a id="newLink" href="#" onclick="blankMailer(); return false;">New</a>

<script>
function onBodyLoad() {
/* //not working, would like to allow files to drop into the iframe too
  var f = document.getElementById('dropFrame');
  b = f.contentWindow.document.body;
  b.ondrop = dropHandler;
  b.ondragenter= dragEnterHandler;
  b.ondragover=dragOverHandler;
*/
  repaint();
}

function repaint() {
  var pw = password();
  var pe = document.getElementById('passwordEntry');
  var wk = document.getElementById('workspace');
  var em = document.getElementById('encMessage');
  if(pw.value == '') {
    pw.focus();
    pe.style.display = 'block';
    wk.style.display = 'none';
    em.style.display = 'none';
  }
  else {
    pe.style.display = 'none';
    wk.style.display = 'block';
    em.style.display = 'block';
  }
  var dropFrame = document.getElementById('dropFrame');
  dropFrame.innerHTML = '';
  var hasFiles = false;
  for(var name in files) {
    f = files[name];
    addFileLink(name);
    hasFiles = true;
  }
  
  var si = document.getElementById('saveInstructions');
  if(hasFiles) {
    si.style.display = 'block';
  } else {
    si.style.display = 'none';
  }
  var newLink = document.getElementById('newLink');
  var pad = document.getElementById('fileDropMessage');
  var dragAndDrop = pad.style.display == 'block';
  if(dragAndDrop && document.getElementById('inputForm')) { 
    newLink.style.display = 'block'; 
  } else {
    newLink.style.display = 'none';
  }
}

files={};
file_id = 0;
function passwordEntry() {
  var fs = input('fileStruct');
  if(fs.value != '') {
    try {
      eval('files = ' + decrypt(fs.value, password().value, 'AES'));
    } catch(Err) {
      alert("Password is incorrect.\n" + Err);
      throw Err;
    }
  }
  for(f in files) {
    file_id = Math.max(file_id, files[f].id);
  }
  repaint();
  return false;
}

function fileStruct(name) {
  var f = files[name];//makes file names unique
  if(f == null) {
    f = {"id" : null, "len": null, "mime": null, "algorithm" : null};
    f.id = ++file_id;
    files[name] = f;
  }
  return f; 
};

function dropHandler(event) {
  if(password().value == '') {
    event.stopPropagation();
    return;
  }
  var files = event.dataTransfer.files;
  for(var i = 0; i < files.length; i++) {
    var file = files[i];
    addFile(file, function(file) {
      addFileLink(file.name);
      domCommit();
      sizeIframe();
    });
  }
  event.stopPropagation();
}

function sizeIframe() {
  var f = document.getElementById('dropFrame');
  //scrollHeight was always 150 even as files are added
  //f.height = f.contentWindow.document.body.scrollHeight;
}

function addFile(file, callback) {
  var f = fileStruct(file.name);
  if(f.len != null)
    return false;//already exists
  
  readFile(file, function(data) {
    //FF window.open returned null in this block, work-around by
    //reading the file now
    fileLoaded(file, data);
    callback(file);
  });
}

function readFile(file, callback) {
  var reader = new FileReader();
  reader.onload = function (evt) {
    callback(evt);
  }
  reader.readAsDataURL(file);//this gives us the mime type
  //Preferred binary, however there is no mime type.
  //reader.readAsBinaryString(file, 'UTF-8');
}

function fileLoaded(file, evt) {
  var f = fileStruct(file.name);
  f.len = evt.total;
  f.algorithm = f.len > 80000 ? 'TEA' : 'AES';
    
  var pw = password().value;
  
  var data = evt.target.result;
  var header;
  try {
    header = data.substring(0, Math.min(50, data.length));
    //data:image/x-icon;base64,AAABAA...
    f.mime = header.split(';')[0].split(':')[1];
    
    //get just the base 64 data
    d = data.substring(
      data.indexOf('base64,') + 'base64,'.length, 
      data.length);
    
    //make it smaller for storage
    d = encrypt(d, pw, f.algorithm);
    input("file_" + f.id).value = d;
  } catch(Err) {
    alert("Expected data URI, instead got: \n" + header + "\n\n" + Err);
  }
}

/** Create or return hidden input field under 'id' */
function input(id) {
  var inputForm = document.getElementById('inputForm');
  if(inputForm == null) {
    inputForm = document.createElement('form');
    inputForm.id = 'inputForm';
    document.body.appendChild(inputForm);
  }
  var input = document.getElementById(id);
  if(input == null) {
    input = document.createElement('input');
    input.id = id;
    input.type = 'hidden';
    inputForm.appendChild(input);
  }
  return input;
}

function addFileLink(name) {
  var f = document.getElementById('dropFrame');
  var doc = f.document || f.contentWindow.document;
  var div = doc.createElement('div');
  doc.body.appendChild(div);
  
  var a = doc.createElement('a');
  a.textContent = name;
  a.target = '_blank';
  a.onclick = saveAs; 
  a.href = "#" + name;
  div.appendChild(a);
  var sp = document.createElement('span');
  var f = fileStruct(name);
  sp.innerHTML = ' (' + addCommas(f.len) + ' bytes)';
  div.appendChild(sp);
}

/* Writes encrypted data structures from memory to the DOM */
function domCommit() {
  var pw = password();
  var fs = input('fileStruct');
  var data = JSON.stringify(files);
  fs.value = encrypt(data, pw.value, "AES");
}

/* Display image.  Warning, places unencrypted data in the DOM
var mi = files.mime[name];
  if(mi != null) {
    if(mi.indexOf('image') == 0) {
      var im = document.createElement('img');
      var pw = password().value;
      if(pw == '')
        im.src = files.data[name];
      else
        im.src = decrypt(files.data[name], password().value);
        
      im.alt = name;
      div.appendChild(im);
    }
    div.appendChild(document.createElement('br'));
  }
*/
function password() {
  return document.getElementById('password');
}

function bodyClick() {
  var pw = password();
  password().focus();
}

function saveAs(event) {
  var name = event.target.innerHTML;
  var f = fileStruct(name)
  var data = input("file_" + f.id).value;
  try {
    data = decrypt(data, password().value, f.algorithm);
  } catch(err) {
    password().value = '';
    repaint();
    alert("Password is incorrect.\n" + err);
    return false;
  }
  var w = window.open("data:" + f.mime + ";base64," + data, '_blank');
  w.document.close();
  return false;
}

function blankMailer() {
  var w = window.open("mailer.html", "_blank");
  var mydoc = w.document;
  var domHtml = document.documentElement.innerHTML;
  
  //strip out files and file structure
  domHtml = domHtml.replace(/<form id=\"inputForm\">.*<\/form>/m,'');
  mydoc.write(domHtml);
  mydoc.close();
}

function dragEnterHandler(event) {
  // cancel the event if the drag contains data of our type
  event.preventDefault();
}

function dragOverHandler(event) {
  event.dataTransfer.dropEffect = 'move';
  event.preventDefault();
}


/*
function addFileInput() {
  var inputFiles = document.getElementById('fileInput').files;
  if(inputFiles.length > 0) {
    for(var i = 0; i < inputFiles.length; i++) 
      addFile(inputFiles[i]);
  }
  //inputFiles.text.value = '';
}
*/
function addCommas(nStr) {
  nStr += '';
  x = nStr.split('.');
  x1 = x[0];
  x2 = x.length > 1 ? '.' + x[1] : '';
  var rgx = /(\d+)(\d{3})/;
  while (rgx.test(x1)) {
    x1 = x1.replace(rgx, '$1' + ',' + '$2');
  }
  return x1 + x2;
}
</script>

<script>

function encrypt(msg, password, type) {
  if(type == 'AES')
    return AesCtr.encrypt(msg, password, 256);//128 192 256
    
  if(type == 'TEA')
    return Tea.encrypt(msg, password);
}

/**
 Check AES with OpenSSL Example:
 
 echo "U2FsdGVkX18dcMA03YtXXVkP9ULmG9Z1uyQa2iRCR9g=" | 
   openssl enc -d -aes-256-cbc -a -k password
 
*/
function decrypt(msg, password, type) {
  if(type == 'AES')
    return AesCtr.decrypt(msg, password, 256);//128 192 256
    
  if(type == 'TEA')
    return Tea.decrypt(msg, password);
}
  
</script>

<script>
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Block TEA (xxtea) Tiny Encryption Algorithm implementation in JavaScript                      */
/*     (c) Chris Veness 2002-2009: www.movable-type.co.uk/tea-block.html                          */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Algorithm: David Wheeler & Roger Needham, Cambridge University Computer Lab                   */
/*             http://www.cl.cam.ac.uk/ftp/papers/djw-rmn/djw-rmn-tea.html (1994)                 */
/*             http://www.cl.cam.ac.uk/ftp/users/djw3/xtea.ps (1997)                              */
/*             http://www.cl.cam.ac.uk/ftp/users/djw3/xxtea.ps (1998)                             */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Tea = {};  // Tea namespace

/* http://www.movable-type.co.uk/scripts/tea-block.html
 * encrypt text using Corrected Block TEA (xxtea) algorithm
 *
 * @param {string} plaintext String to be encrypted (multi-byte safe)
 * @param {string} password  Password to be used for encryption (1st 16 chars)
 * @returns {string} encrypted text
 */
Tea.encrypt = function(plaintext, password) {
    if (plaintext.length == 0) return('');  // nothing to encrypt
    
    // convert string to array of longs after converting any multi-byte chars to UTF-8
    var v = Tea.strToLongs(Utf8.encode(plaintext));
    if (v.length <= 1) v[1] = 0;  // algorithm doesn't work for n<2 so fudge by adding a null
    // simply convert first 16 chars of password as key
    var k = Tea.strToLongs(Utf8.encode(password).slice(0,16));  
    var n = v.length;
    
    // ---- <TEA coding> ---- 
    
    var z = v[n-1], y = v[0], delta = 0x9E3779B9;
    var mx, e, q = Math.floor(6 + 52/n), sum = 0;
    
    while (q-- > 0) {  // 6 + 52/n operations gives between 6 & 32 mixes on each word
        sum += delta;
        e = sum>>>2 & 3;
        for (var p = 0; p < n; p++) {
            y = v[(p+1)%n];
            mx = (z>>>5 ^ y<<2) + (y>>>3 ^ z<<4) ^ (sum^y) + (k[p&3 ^ e] ^ z);
            z = v[p] += mx;
        }
    }
    
    // ---- </TEA> ----
    
    var ciphertext = Tea.longsToStr(v);
    
    return Base64.encode(ciphertext);
}

/*
 * decrypt text using Corrected Block TEA (xxtea) algorithm
 *
 * @param {string} ciphertext String to be decrypted
 * @param {string} password   Password to be used for decryption (1st 16 chars)
 * @returns {string} decrypted text
 */
Tea.decrypt = function(ciphertext, password) {
    if (ciphertext.length == 0) return('');
    var v = Tea.strToLongs(Base64.decode(ciphertext));
    var k = Tea.strToLongs(Utf8.encode(password).slice(0,16)); 
    var n = v.length;
    
    // ---- <TEA decoding> ---- 
    
    var z = v[n-1], y = v[0], delta = 0x9E3779B9;
    var mx, e, q = Math.floor(6 + 52/n), sum = q*delta;

    while (sum != 0) {
        e = sum>>>2 & 3;
        for (var p = n-1; p >= 0; p--) {
            z = v[p>0 ? p-1 : n-1];
            mx = (z>>>5 ^ y<<2) + (y>>>3 ^ z<<4) ^ (sum^y) + (k[p&3 ^ e] ^ z);
            y = v[p] -= mx;
        }
        sum -= delta;
    }
    
    // ---- </TEA> ---- 
    
    var plaintext = Tea.longsToStr(v);

    // strip trailing null chars resulting from filling 4-char blocks:
    plaintext = plaintext.replace(/\0+$/,'');

    return Utf8.decode(plaintext);
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

// supporting functions

Tea.strToLongs = function(s) {  // convert string to array of longs, each containing 4 chars
    // note chars must be within ISO-8859-1 (with Unicode code-point < 256) to fit 4/long
    var l = new Array(Math.ceil(s.length/4));
    for (var i=0; i<l.length; i++) {
        // note little-endian encoding - endianness is irrelevant as long as 
        // it is the same in longsToStr() 
        l[i] = s.charCodeAt(i*4) + (s.charCodeAt(i*4+1)<<8) + 
               (s.charCodeAt(i*4+2)<<16) + (s.charCodeAt(i*4+3)<<24);
    }
    return l;  // note running off the end of the string generates nulls since 
}              // bitwise operators treat NaN as 0

Tea.longsToStr = function(l) {  // convert array of longs back to string
    var a = new Array(l.length);
    for (var i=0; i<l.length; i++) {
        a[i] = String.fromCharCode(l[i] & 0xFF, l[i]>>>8 & 0xFF, 
                                   l[i]>>>16 & 0xFF, l[i]>>>24 & 0xFF);
    }
    return a.join('');  // use Array.join() rather than repeated string appends for efficiency in IE
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  AES implementation in JavaScript (c) Chris Veness 2005-2009                                   */
/*   - see http://csrc.nist.gov/publications/PubsFIPS.html#197                                    */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Aes = {};  // Aes namespace

/**
 * AES Cipher function: encrypt 'input' state with Rijndael algorithm
 *   applies Nr rounds (10/12/14) using key schedule w for 'add round key' stage
 *
 * http://www.movable-type.co.uk/scripts/aes.html
 *
 * @param {Number[]} input 16-byte (128-bit) input state array
 * @param {Number[][]} w   Key schedule as 2D byte-array (Nr+1 x Nb bytes)
 * @returns {Number[]}     Encrypted output state array
 */
Aes.Cipher = function(input, w) {    // main Cipher function [§5.1]
  var Nb = 4;               // block size (in words): no of columns in state (fixed at 4 for AES)
  var Nr = w.length/Nb - 1; // no of rounds: 10/12/14 for 128/192/256-bit keys

  var state = [[],[],[],[]];  // initialise 4xNb byte-array 'state' with input [§3.4]
  for (var i=0; i<4*Nb; i++) state[i%4][Math.floor(i/4)] = input[i];

  state = Aes.AddRoundKey(state, w, 0, Nb);

  for (var round=1; round<Nr; round++) {
    state = Aes.SubBytes(state, Nb);
    state = Aes.ShiftRows(state, Nb);
    state = Aes.MixColumns(state, Nb);
    state = Aes.AddRoundKey(state, w, round, Nb);
  }

  state = Aes.SubBytes(state, Nb);
  state = Aes.ShiftRows(state, Nb);
  state = Aes.AddRoundKey(state, w, Nr, Nb);

  var output = new Array(4*Nb);  // convert state to 1-d array before returning [§3.4]
  for (var i=0; i<4*Nb; i++) output[i] = state[i%4][Math.floor(i/4)];
  return output;
}

/**
 * Perform Key Expansion to generate a Key Schedule
 *
 * @param {Number[]} key Key as 16/24/32-byte array
 * @returns {Number[][]} Expanded key schedule as 2D byte-array (Nr+1 x Nb bytes)
 */
Aes.KeyExpansion = function(key) {  // generate Key Schedule (byte-array Nr+1 x Nb) from Key [§5.2]
  var Nb = 4;            // block size (in words): no of columns in state (fixed at 4 for AES)
  var Nk = key.length/4  // key length (in words): 4/6/8 for 128/192/256-bit keys
  var Nr = Nk + 6;       // no of rounds: 10/12/14 for 128/192/256-bit keys

  var w = new Array(Nb*(Nr+1));
  var temp = new Array(4);

  for (var i=0; i<Nk; i++) {
    var r = [key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]];
    w[i] = r;
  }

  for (var i=Nk; i<(Nb*(Nr+1)); i++) {
    w[i] = new Array(4);
    for (var t=0; t<4; t++) temp[t] = w[i-1][t];
    if (i % Nk == 0) {
      temp = Aes.SubWord(Aes.RotWord(temp));
      for (var t=0; t<4; t++) temp[t] ^= Aes.Rcon[i/Nk][t];
    } else if (Nk > 6 && i%Nk == 4) {
      temp = Aes.SubWord(temp);
    }
    for (var t=0; t<4; t++) w[i][t] = w[i-Nk][t] ^ temp[t];
  }

  return w;
}

/*
 * ---- remaining routines are private, not called externally ----
 */
 
Aes.SubBytes = function(s, Nb) {    // apply SBox to state S [§5.1.1]
  for (var r=0; r<4; r++) {
    for (var c=0; c<Nb; c++) s[r][c] = Aes.Sbox[s[r][c]];
  }
  return s;
}

Aes.ShiftRows = function(s, Nb) {    // shift row r of state S left by r bytes [§5.1.2]
  var t = new Array(4);
  for (var r=1; r<4; r++) {
    for (var c=0; c<4; c++) t[c] = s[r][(c+r)%Nb];  // shift into temp copy
    for (var c=0; c<4; c++) s[r][c] = t[c];         // and copy back
  }          // note that this will work for Nb=4,5,6, but not 7,8 (always 4 for AES):
  return s;  // see asmaes.sourceforge.net/rijndael/rijndaelImplementation.pdf
}

Aes.MixColumns = function(s, Nb) {   // combine bytes of each col of state S [§5.1.3]
  for (var c=0; c<4; c++) {
    var a = new Array(4);  // 'a' is a copy of the current column from 's'
    var b = new Array(4);  // 'b' is a•{02} in GF(2^8)
    for (var i=0; i<4; i++) {
      a[i] = s[i][c];
      b[i] = s[i][c]&0x80 ? s[i][c]<<1 ^ 0x011b : s[i][c]<<1;
    }
    // a[n] ^ b[n] is a•{03} in GF(2^8)
    s[0][c] = b[0] ^ a[1] ^ b[1] ^ a[2] ^ a[3]; // 2*a0 + 3*a1 + a2 + a3
    s[1][c] = a[0] ^ b[1] ^ a[2] ^ b[2] ^ a[3]; // a0 * 2*a1 + 3*a2 + a3
    s[2][c] = a[0] ^ a[1] ^ b[2] ^ a[3] ^ b[3]; // a0 + a1 + 2*a2 + 3*a3
    s[3][c] = a[0] ^ b[0] ^ a[1] ^ a[2] ^ b[3]; // 3*a0 + a1 + a2 + 2*a3
  }
  return s;
}

Aes.AddRoundKey = function(state, w, rnd, Nb) {  // xor Round Key into state S [§5.1.4]
  for (var r=0; r<4; r++) {
    for (var c=0; c<Nb; c++) state[r][c] ^= w[rnd*4+c][r];
  }
  return state;
}

Aes.SubWord = function(w) {    // apply SBox to 4-byte word w
  for (var i=0; i<4; i++) w[i] = Aes.Sbox[w[i]];
  return w;
}

Aes.RotWord = function(w) {    // rotate 4-byte word w left by one byte
  var tmp = w[0];
  for (var i=0; i<3; i++) w[i] = w[i+1];
  w[3] = tmp;
  return w;
}

// Sbox is pre-computed multiplicative inverse in GF(2^8) used in SubBytes and KeyExpansion [§5.1.1]
Aes.Sbox =  [0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
             0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
             0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
             0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
             0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
             0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
             0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
             0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
             0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
             0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
             0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
             0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
             0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
             0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
             0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
             0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16];

// Rcon is Round Constant used for the Key Expansion [1st col is 2^(r-1) in GF(2^8)] [§5.2]
Aes.Rcon = [ [0x00, 0x00, 0x00, 0x00],
             [0x01, 0x00, 0x00, 0x00],
             [0x02, 0x00, 0x00, 0x00],
             [0x04, 0x00, 0x00, 0x00],
             [0x08, 0x00, 0x00, 0x00],
             [0x10, 0x00, 0x00, 0x00],
             [0x20, 0x00, 0x00, 0x00],
             [0x40, 0x00, 0x00, 0x00],
             [0x80, 0x00, 0x00, 0x00],
             [0x1b, 0x00, 0x00, 0x00],
             [0x36, 0x00, 0x00, 0x00] ]; 


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  AES Counter-mode implementation in JavaScript (c) Chris Veness 2005-2009                      */
/*   - see http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf                       */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var AesCtr = {};  // AesCtr namespace

/** 
 * Encrypt a text using AES encryption in Counter mode of operation
 *
 * Unicode multi-byte character safe
 *
 * @param {String} plaintext Source text to be encrypted
 * @param {String} password  The password to use to generate a key
 * @param {Number} nBits     Number of bits to be used in the key (128, 192, or 256)
 * @returns {string}         Encrypted text
 */
AesCtr.encrypt = function(plaintext, password, nBits) {
  var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
  if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
  plaintext = Utf8.encode(plaintext);
  password = Utf8.encode(password);
  //var t = new Date();  // timer
        
  // use AES itself to encrypt password to get cipher key (using plain password as source for key 
  // expansion) - gives us well encrypted key
  var nBytes = nBits/8;  // no bytes in key
  var pwBytes = new Array(nBytes);
  for (var i=0; i<nBytes; i++) {
    pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
  }
  var key = Aes.Cipher(pwBytes, Aes.KeyExpansion(pwBytes));  // gives us 16-byte key
  key = key.concat(key.slice(0, nBytes-16));  // expand key to 16/24/32 bytes long

  // initialise counter block (NIST SP800-38A §B.2): millisecond time-stamp for nonce in 1st 8 bytes,
  // block counter in 2nd 8 bytes
  var counterBlock = new Array(blockSize);
  var nonce = (new Date()).getTime();  // timestamp: milliseconds since 1-Jan-1970
  var nonceSec = Math.floor(nonce/1000);
  var nonceMs = nonce%1000;
  // encode nonce with seconds in 1st 4 bytes, and (repeated) ms part filling 2nd 4 bytes
  for (var i=0; i<4; i++) counterBlock[i] = (nonceSec >>> i*8) & 0xff;
  for (var i=0; i<4; i++) counterBlock[i+4] = nonceMs & 0xff; 
  // and convert it to a string to go on the front of the ciphertext
  var ctrTxt = '';
  for (var i=0; i<8; i++) ctrTxt += String.fromCharCode(counterBlock[i]);

  // generate key schedule - an expansion of the key into distinct Key Rounds for each round
  var keySchedule = Aes.KeyExpansion(key);
  
  var blockCount = Math.ceil(plaintext.length/blockSize);
  var ciphertxt = new Array(blockCount);  // ciphertext as array of strings
  
  for (var b=0; b<blockCount; b++) {
    // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
    // done in two stages for 32-bit ops: using two words allows us to go past 2^32 blocks (68GB)
    for (var c=0; c<4; c++) counterBlock[15-c] = (b >>> c*8) & 0xff;
    for (var c=0; c<4; c++) counterBlock[15-c-4] = (b/0x100000000 >>> c*8)

    var cipherCntr = Aes.Cipher(counterBlock, keySchedule);  // -- encrypt counter block --
    
    // block size is reduced on final block
    var blockLength = b<blockCount-1 ? blockSize : (plaintext.length-1)%blockSize+1;
    var cipherChar = new Array(blockLength);
    
    for (var i=0; i<blockLength; i++) {  // -- xor plaintext with ciphered counter char-by-char --
      cipherChar[i] = cipherCntr[i] ^ plaintext.charCodeAt(b*blockSize+i);
      cipherChar[i] = String.fromCharCode(cipherChar[i]);
    }
    ciphertxt[b] = cipherChar.join(''); 
  }

  // Array.join is more efficient than repeated string concatenation in IE
  var ciphertext = ctrTxt + ciphertxt.join('');
  ciphertext = Base64.encode(ciphertext);  // encode in base64
  
  //alert((new Date()) - t);
  return ciphertext;
}

/** 
 * Decrypt a text encrypted by AES in counter mode of operation
 *
 * @param {String} ciphertext Source text to be encrypted
 * @param {String} password   The password to use to generate a key
 * @param {Number} nBits      Number of bits to be used in the key (128, 192, or 256)
 * @returns {String}          Decrypted text
 */
AesCtr.decrypt = function(ciphertext, password, nBits) {
  var blockSize = 16;  // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
  if (!(nBits==128 || nBits==192 || nBits==256)) return '';  // standard allows 128/192/256 bit keys
  ciphertext = Base64.decode(ciphertext);
  password = Utf8.encode(password);
  //var t = new Date();  // timer
  
  // use AES to encrypt password (mirroring encrypt routine)
  var nBytes = nBits/8;  // no bytes in key
  var pwBytes = new Array(nBytes);
  for (var i=0; i<nBytes; i++) {
    pwBytes[i] = isNaN(password.charCodeAt(i)) ? 0 : password.charCodeAt(i);
  }
  var key = Aes.Cipher(pwBytes, Aes.KeyExpansion(pwBytes));
  key = key.concat(key.slice(0, nBytes-16));  // expand key to 16/24/32 bytes long

  // recover nonce from 1st 8 bytes of ciphertext
  var counterBlock = new Array(8);
  ctrTxt = ciphertext.slice(0, 8);
  for (var i=0; i<8; i++) counterBlock[i] = ctrTxt.charCodeAt(i);
  
  // generate key schedule
  var keySchedule = Aes.KeyExpansion(key);

  // separate ciphertext into blocks (skipping past initial 8 bytes)
  var nBlocks = Math.ceil((ciphertext.length-8) / blockSize);
  var ct = new Array(nBlocks);
  for (var b=0; b<nBlocks; b++) ct[b] = ciphertext.slice(8+b*blockSize, 8+b*blockSize+blockSize);
  ciphertext = ct;  // ciphertext is now array of block-length strings

  // plaintext will get generated block-by-block into array of block-length strings
  var plaintxt = new Array(ciphertext.length);

  for (var b=0; b<nBlocks; b++) {
    // set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
    for (var c=0; c<4; c++) counterBlock[15-c] = ((b) >>> c*8) & 0xff;
    for (var c=0; c<4; c++) counterBlock[15-c-4] = (((b+1)/0x100000000-1) >>> c*8) & 0xff;

    var cipherCntr = Aes.Cipher(counterBlock, keySchedule);  // encrypt counter block

    var plaintxtByte = new Array(ciphertext[b].length);
    for (var i=0; i<ciphertext[b].length; i++) {
      // -- xor plaintxt with ciphered counter byte-by-byte --
      plaintxtByte[i] = cipherCntr[i] ^ ciphertext[b].charCodeAt(i);
      plaintxtByte[i] = String.fromCharCode(plaintxtByte[i]);
    }
    plaintxt[b] = plaintxtByte.join('');
  }

  // join array of blocks into single plaintext string
  var plaintext = plaintxt.join('');
  plaintext = Utf8.decode(plaintext);  // decode from UTF8 back to Unicode multi-byte chars
  
  //alert((new Date()) - t);
  return plaintext;
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Base64 class: Base 64 encoding / decoding (c) Chris Veness 2002-2009                          */
/*    note: depends on Utf8 class                                                                 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Base64 = {};  // Base64 namespace

Base64.code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

/**
 * Encode string into Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
 * (instance method extending String object). As per RFC 4648, no newlines are added.
 *
 * @param {String} str The string to be encoded as base-64
 * @param {Boolean} [utf8encode=false] Flag to indicate whether str is Unicode string to be encoded 
 *   to UTF8 before conversion to base64; otherwise string is assumed to be 8-bit characters
 * @returns {String} Base64-encoded string
 */ 
Base64.encode = function(str, utf8encode) {  // http://tools.ietf.org/html/rfc4648
  utf8encode =  (typeof utf8encode == 'undefined') ? false : utf8encode;
  var o1, o2, o3, bits, h1, h2, h3, h4, e=[], pad = '', c, plain, coded;
  var b64 = Base64.code;
   
  plain = utf8encode ? str.encodeUTF8() : str;
  
  c = plain.length % 3;  // pad string to length of multiple of 3
  if (c > 0) { while (c++ < 3) { pad += '='; plain += '\0'; } }
  // note: doing padding here saves us doing special-case packing for trailing 1 or 2 chars
   
  for (c=0; c<plain.length; c+=3) {  // pack three octets into four hexets
    o1 = plain.charCodeAt(c);
    o2 = plain.charCodeAt(c+1);
    o3 = plain.charCodeAt(c+2);
      
    bits = o1<<16 | o2<<8 | o3;
      
    h1 = bits>>18 & 0x3f;
    h2 = bits>>12 & 0x3f;
    h3 = bits>>6 & 0x3f;
    h4 = bits & 0x3f;

    // use hextets to index into code string
    e[c/3] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
  }
  coded = e.join('');  // join() is far faster than repeated string concatenation in IE
  
  // replace 'A's from padded nulls with '='s
  coded = coded.slice(0, coded.length-pad.length) + pad;
   
  return coded;
}

/**
 * Decode string from Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
 * (instance method extending String object). As per RFC 4648, newlines are not catered for.
 *
 * @param {String} str The string to be decoded from base-64
 * @param {Boolean} [utf8decode=false] Flag to indicate whether str is Unicode string to be decoded 
 *   from UTF8 after conversion from base64
 * @returns {String} decoded string
 */ 
Base64.decode = function(str, utf8decode) {
  utf8decode =  (typeof utf8decode == 'undefined') ? false : utf8decode;
  var o1, o2, o3, h1, h2, h3, h4, bits, d=[], plain, coded;
  var b64 = Base64.code;

  coded = utf8decode ? str.decodeUTF8() : str;
  
  
  for (var c=0; c<coded.length; c+=4) {  // unpack four hexets into three octets
    h1 = b64.indexOf(coded.charAt(c));
    h2 = b64.indexOf(coded.charAt(c+1));
    h3 = b64.indexOf(coded.charAt(c+2));
    h4 = b64.indexOf(coded.charAt(c+3));
      
    bits = h1<<18 | h2<<12 | h3<<6 | h4;
      
    o1 = bits>>>16 & 0xff;
    o2 = bits>>>8 & 0xff;
    o3 = bits & 0xff;
    
    d[c/4] = String.fromCharCode(o1, o2, o3);
    // check for padding
    if (h4 == 0x40) d[c/4] = String.fromCharCode(o1, o2);
    if (h3 == 0x40) d[c/4] = String.fromCharCode(o1);
  }
  plain = d.join('');  // join() is far faster than repeated string concatenation in IE
   
  return utf8decode ? plain.decodeUTF8() : plain; 
}


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
/*  Utf8 class: encode / decode between multi-byte Unicode characters and UTF-8 multiple          */
/*              single-byte character encoding (c) Chris Veness 2002-2009                         */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

var Utf8 = {};  // Utf8 namespace

/**
 * Encode multi-byte Unicode string into utf-8 multiple single-byte characters 
 * (BMP / basic multilingual plane only)
 *
 * Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars
 *
 * @param {String} strUni Unicode string to be encoded as UTF-8
 * @returns {String} encoded string
 */
Utf8.encode = function(strUni) {
  // use regular expressions & String.replace callback function for better efficiency 
  // than procedural approaches
  var strUtf = strUni.replace(
      /[\u0080-\u07ff]/g,  // U+0080 - U+07FF => 2 bytes 110yyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0);
        return String.fromCharCode(0xc0 | cc>>6, 0x80 | cc&0x3f); }
    );
  strUtf = strUtf.replace(
      /[\u0800-\uffff]/g,  // U+0800 - U+FFFF => 3 bytes 1110xxxx, 10yyyyyy, 10zzzzzz
      function(c) { 
        var cc = c.charCodeAt(0); 
        return String.fromCharCode(0xe0 | cc>>12, 0x80 | cc>>6&0x3F, 0x80 | cc&0x3f); }
    );
  return strUtf;
}

/**
 * Decode utf-8 encoded string back into multi-byte Unicode characters
 *
 * @param {String} strUtf UTF-8 string to be decoded back to Unicode
 * @returns {String} decoded string
 */
Utf8.decode = function(strUtf) {
  var strUni = strUtf.replace(
      /[\u00c0-\u00df][\u0080-\u00bf]/g,                 // 2-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = (c.charCodeAt(0)&0x1f)<<6 | c.charCodeAt(1)&0x3f;
        return String.fromCharCode(cc); }
    );
  strUni = strUni.replace(
      /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g,  // 3-byte chars
      function(c) {  // (note parentheses for precence)
        var cc = ((c.charCodeAt(0)&0x0f)<<12) | ((c.charCodeAt(1)&0x3f)<<6) | ( c.charCodeAt(2)&0x3f); 
        return String.fromCharCode(cc); }
    );
  return strUni;
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
</script>
</body>
</html>
